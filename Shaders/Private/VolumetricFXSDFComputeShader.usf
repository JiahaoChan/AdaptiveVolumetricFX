// Copyright Technical Artist - Jiahao.Chan, Individual. All Rights Reserved.

#include "/Engine/Private/Common.ush" 
#include "/Engine/Public/Platform.ush"

#ifndef SMIN_FUNCTION_EXPONENTIAL
#define SMIN_FUNCTION_EXPONENTIAL 0
#endif

#ifndef SMIN_FUNCTION_ROOT
#define SMIN_FUNCTION_ROOT 1
#endif

#ifndef SMIN_FUNCTION_SIGMOID
#define SMIN_FUNCTION_SIGMOID 2
#endif

#ifndef SMIN_FUNCTION_QUADRATICPOLYNOMIAL
#define SMIN_FUNCTION_QUADRATICPOLYNOMIAL 3
#endif

#ifndef SMIN_FUNCTION_CUBICPOLYNOMIAL
#define SMIN_FUNCTION_CUBICPOLYNOMIAL 4
#endif

#ifndef SMIN_FUNCTION_QUARTICPOLYNOMIAL
#define SMIN_FUNCTION_QUARTICPOLYNOMIAL 5
#endif

#ifndef SMIN_FUNCTION_CIRCULAR
#define SMIN_FUNCTION_CIRCULAR 6
#endif

#ifndef SDF_BLEND_FUNCTION
#define SDF_BLEND_FUNCTION SMIN_FUNCTION_ROOT
#endif

struct FSubductionConeShape
{
    float3 Axis;
    float3 Point;
    float Height;
    float BottomRadius;
    float TopRadius;
};

struct FSphereShape
{
    float3 Axis;
    float Radius;
};

RWBuffer<int> Output;

// Input
uint VoxelCount;
Buffer<float3> VoxelPointLocations;
float BoundsSize;
/**
 * One Layer = LayerResolution * LayerResolution
 */
uint LayerResolution;
/**
 * LayerCount = LayerTilesCount * LayerTilesCount;
 */
uint LayerTilesCount;
float InnerRadius;
float OuterRadius;
float FactorK;

uint ConeCount;
StructuredBuffer<FSubductionConeShape> ConeShapes;
//uint SphereCount;
//StructuredBuffer<FSphereShape> SphereShapes;

// Output
RWTexture2D<float> SDFTexture;

//~ Begin SDF Blend SMin Function
float Exponential(float A, float B, float K)
{
    float r = exp(-A / K) + exp2(-B / K);
    return -K * log2(r);
}

float Root(float A, float B, float K)
{
    K *= K;
    float x = B - A;
    return 0.5 * (A + B - sqrt(x * x + K * K));
}

float Sigmoid(float A, float B, float K)
{
    K *= log2(2.0);
    float x = B - A;
    return A + x / (1.0 - exp2(x / K));
}

float QuadraticPolynomial(float A, float B, float K)
{
    K *= 4.0;
    float h = max(K - abs(A - B), 0.0) / K;
    return min(A, B) - h * h * K * 0.25;
}

float CubicPolynomial(float A, float B, float K)
{
    K *= 6.0;
    float h = max(K - abs(A - B), 0.0) / K;
    return min(A, B) - h * h * h * K * (1.0 / 6.0);
}

float QuarticPolynomial(float A, float B, float K)
{
    K *= 16.0 / 3.0;
    float h = max(K - abs(A - B), 0.0) / K;
    return min(A, B) - h * h * h * (4.0 - h) * K * (1.0 / 16.0);
}

float Circular(float A, float B, float K)
{
    K *= 1.0 / (1.0 - sqrt(0.5));
    float h = max(K - abs(A - B), 0.0) / K;
    return min(A, B) - K * 0.5 * (1.0 + h - sqrt(1.0 - h * (h - 2.0)));
}
//~ End SDF Blend SMin Function

float ConeOutside(float3 QueryLocation, FSubductionConeShape Cone)
{
    float3 ToPoint = QueryLocation - Cone.Point;
    float Height = dot(ToPoint, Cone.Axis);
    if (Height < 0.0 || Height > Cone.Height)
    {
        return 1.0; // 点在高度范围外 → 外部 → 返回 1
    }
    
    float RadialDistance = length(ToPoint - Height * Cone.Axis);
    float RadiusAtHeight = lerp(Cone.BottomRadius, Cone.TopRadius, Height / Cone.Height);
    return RadialDistance <= RadiusAtHeight ? 0.0 : 1.0;
}

float SphereDF(float3 QueryLocation, float3 Point, float Radius)
{
    return distance(QueryLocation, Point) - Radius;
}

float GetLocationSDFValue(float CurrentSDF, float3 QueryLocation, float3 VoxelPointLocation)
{
    float Value = saturate(SphereDF(QueryLocation, VoxelPointLocation, InnerRadius) / OuterRadius);
    
#if SDF_BLEND_FUNCTION == SMIN_FUNCTION_EXPONENTIAL
    return Exponential(Value, CurrentSDF, FactorK);
#elif SDF_BLEND_FUNCTION == SMIN_FUNCTION_ROOT
    return Root(Value, CurrentSDF, FactorK);
#elif SDF_BLEND_FUNCTION == SMIN_FUNCTION_SIGMOID
    return Sigmoid(Value, CurrentSDF, FactorK);
#elif SDF_BLEND_FUNCTION == SMIN_FUNCTION_QUADRATICPOLYNOMIAL
    return QuadraticPolynomial(Value, CurrentSDF, FactorK);
#elif SDF_BLEND_FUNCTION == SMIN_FUNCTION_CUBICPOLYNOMIAL
    return CubicPolynomial(Value, CurrentSDF, FactorK);
#elif SDF_BLEND_FUNCTION == SMIN_FUNCTION_QUARTICPOLYNOMIAL
    return QuarticPolynomial(Value, CurrentSDF, FactorK);
#elif SDF_BLEND_FUNCTION == SMIN_FUNCTION_CIRCULAR
    return Circular(Value, CurrentSDF, FactorK);
#else
    return 1.0f;
#endif
}

float3 ConvertVolumeTextureUVToBoundsLocation(float3 UV)
{
    return (UV - float3(0.5, 0.5, 0.5)) * BoundsSize;
}

float3 ConvertFlattenUVToVolumeTextureUV(float2 UV)
{
    float3 VolumeTextureUV = 0;
    VolumeTextureUV.xy = frac(UV * LayerTilesCount);
    float2 LayerCoordinate = floor(UV * LayerTilesCount);
    float LayerIndex = LayerCoordinate.y * LayerTilesCount + LayerCoordinate.x;
    VolumeTextureUV.z = LayerIndex / (LayerTilesCount * LayerTilesCount - 1);
    return VolumeTextureUV;
}

[numthreads(THREADTILES, THREADTILES, 1)]
void Main(
    uint3 DispatchThreadId : SV_DispatchThreadID,
    uint GroupIndex : SV_GroupIndex)
{
    Output[0] = 1.0f;
    /*
    for (int i = 0; i < 512; i++)
    {
        SDFTexture[float2(i, 0.0)] = 0.5;
    }
    */
    
    uint TextureResolution = LayerResolution * LayerTilesCount;
    float UVIntervalPerTexel = 1.0 / TextureResolution;
    uint PixelTilesCountPerThread = TextureResolution / THREADTILES;
    for (uint y = 0; y < PixelTilesCountPerThread; y++)
    {
        for (uint x = 0; x < PixelTilesCountPerThread; x++)
        {
            uint2 TexelPosition = uint2(x, y) + DispatchThreadId.xy * uint2(PixelTilesCountPerThread, PixelTilesCountPerThread);
            float2 FlattenUV = float2(TexelPosition.x, TexelPosition.y) / float2(TextureResolution, TextureResolution) + UVIntervalPerTexel * 0.5;
            float3 VolumeTextureUV = ConvertFlattenUVToVolumeTextureUV(FlattenUV);
            float3 LocationInBounds = ConvertVolumeTextureUVToBoundsLocation(VolumeTextureUV);
            float SDFValue = 1.0;
            for (uint i = 0; i < VoxelCount; i++)
            {
                // Voxel Point Location is in World space.
                SDFValue = GetLocationSDFValue(SDFValue, LocationInBounds, VoxelPointLocations[i]);
            }
            
            //for (uint i = 0; i < ConeCount; i++)
            //{
                //SDFValue = saturate(SDFValue + 1.0 - ConeOutside(LocationInBounds, ConeShapes[i]));
            //}
            
            SDFTexture[TexelPosition] = SDFValue;
        }
    }
}